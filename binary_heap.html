<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title>binary_heap.rb</title>
  <link rel="stylesheet" href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <table cellspacing=0 cellpadding=0>
  <thead>
    <tr>
      <th class=docs><h1>binary_heap.rb</h1></th>
      <th class=code></th>
    </tr>
  </thead>
  <tbody>
    <tr id='section-1'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-1">&#182;</a>
        </div>
        <p>A heap is a common implementation of a priority queue. It stores a list of
elements, and enables the &ldquo;highest priority&rdquo; element to be pulled off the
list.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre></pre></div>
      </td>
    </tr>
    <tr id='section-2'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-2">&#182;</a>
        </div>
        <p>A binary heap is a priority queue implemented using a binary tree. Each node
of the tree satifies the <em>heap property</em>, namely that the value of each node
is greater than all of its children. In this implementation, &ldquo;greater&rdquo; is
abstract and can be any comparison function. For a min-heap, the &ldquo;greatest&rdquo;
value in this terminology will actually be the smallest number.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><span class="k">class</span> <span class="nc">BinaryHeap</span></pre></div>
      </td>
    </tr>
    <tr id='section-Overview'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-Overview">&#182;</a>
        </div>
        <h2>Overview</h2>

<p>Internally, the heap is able to efficiently store the binary tree as an
array since the tree will conform to the &ldquo;shape property&rdquo;, meaning it will
be fully filled and not unbalanced. The top of the heap is the first
element in the heap, the bottom is the last. This format is explained
further below.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">comparator</span><span class="p">)</span>
    <span class="vi">@comparator</span> <span class="o">=</span> <span class="n">comparator</span>
    <span class="vi">@data</span>       <span class="o">=</span> <span class="o">[]</span>
  <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-4'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-4">&#182;</a>
        </div>
        <p>Adding a value to the heap begins by placing the value at the bottom of the
heap. At this point, it is possible that the data structure violates the
<em>heap property</em>, since the new value may be greater than some of its
parents.  To fix this, the value is &ldquo;bubbled&rdquo; up to the correct location by
recursively swapping it with its immediate parent for as long as it is
greater than that parent.</p>

<p>In the worst case of adding a value that is to be the new greatest value,
this will take <em>log n</em> time, since one swap is required for every level of
the tree to get the value from the bottom to the top (the height of a
binary tree is by definition <em>log n</em>).</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>  <span class="k">def</span> <span class="nf">&lt;&lt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">i</span>        <span class="o">=</span> <span class="n">length</span>
    <span class="vi">@data</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span>

    <span class="n">bubble_up</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="nb">self</span>
  <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-5'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-5">&#182;</a>
        </div>
        <p>Removing the top element from the heap is mostly symmetric to insertion.
The trick to rebalance the tree is to fill the hole left by removing the
top element with the bottom element in the heap.  As with insertion, the
structure is now in a state where the <em>heap property</em> may be violated, so
this new value is recursively bubbled <em>down</em> so long as any immediate child
is greater than it.</p>

<p>Once again, the worst case bound for this operation is <code>log n</code>, since if
the bottom element in the heap indeed belongs there it will need to swap
places with every level in the tree to get back down after it is promoted
to the top.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>  <span class="k">def</span> <span class="nf">pop</span>
    <span class="n">value</span>    <span class="o">=</span> <span class="n">top</span>
    <span class="vi">@data</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="vi">@data</span><span class="o">.</span><span class="n">pop</span>

    <span class="n">bubble_down</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">value</span>
  <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-6'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-6">&#182;</a>
        </div>
        <p>Both <code>length</code> and <code>top</code> are trivial constant time operations.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>  <span class="k">def</span> <span class="nf">length</span>
    <span class="vi">@data</span><span class="o">.</span><span class="n">length</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">top</span>
    <span class="vi">@data</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
  <span class="k">end</span>

  <span class="kp">private</span></pre></div>
      </td>
    </tr>
    <tr id='section-Details'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-Details">&#182;</a>
        </div>
        <h2>Details</h2>

<p>A complete binary tree can be stored in an array by flattening it level by
level, left to right. Each level contains twice as many values, so the
distribution of levels will look like:</p>

<pre><code>[0 1 1 2 2 2 2 3 3 3 3 3 3 3 3]
</code></pre>

<p>The root of the tree is at index 0, its left child at 1, right at 2, then
the left most child of the second level is stored at index 3.</p>

<p>Given a value at index <em>i</em>, the left child can be found at <em>2i+1</em> and the
right at <em>2i+2</em>. This can be intuited since the children for <em>i</em> will be
found <em>after</em> all the children for its predecessors, and each predecessor
has two children. Try the calculations on the above array to prove to
yourself that it works.</p>

<p>The algorithm to bubble down a value from the top of the heap to its
appropriate level falls out nicely. Starting at the top, if the value is
<em>not</em> greater than both children it is swapped with the larger of those
children, therefore satisfying the heap property for this level of the
tree. This process is repeated, following the value down the tree, until
either it is greater than both children or it reaches the bottom.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>  <span class="k">def</span> <span class="nf">bubble_down</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">while</span> <span class="kp">true</span>
      <span class="n">left</span>  <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">right</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span>

      <span class="n">child</span> <span class="o">=</span> <span class="n">compare</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="p">?</span> <span class="n">left</span> <span class="p">:</span> <span class="n">right</span>

      <span class="k">if</span> <span class="o">!</span><span class="n">compare</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
        <span class="n">swap!</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">child</span>
      <span class="k">else</span>
        <span class="k">break</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-8'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-8">&#182;</a>
        </div>
        <p>Bubbling a value up from the bottom of the heap is simpler than bubbling
down since only a single comparison against the parent is required. If the
parent is greater, the algorithm terminates. Otherwise, the two are
switched and the process continues up the tree.</p>

<p>Calculating the parent index is a single equation for both left and right
children, since integer division will floor both results.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>  <span class="k">def</span> <span class="nf">bubble_up</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span>
      <span class="n">parent</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>

      <span class="k">if</span> <span class="n">compare</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
        <span class="n">swap!</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
      <span class="k">end</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">parent</span>
    <span class="k">end</span>
  <span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-9'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-9">&#182;</a>
        </div>
        <p>Comparing elements returns <code>true</code> if <code>lhs</code> is greater than <code>rhs</code>. At the
bottom of the heap where <code>rhs</code> would fall beyond the end of the data
structure, <code>true</code> is returned to indicate that the <code>lhs</code> is by default the
greater value.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre>  <span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="n">rhs</span> <span class="o">&gt;=</span> <span class="vi">@data</span><span class="o">.</span><span class="n">length</span>

    <span class="vi">@data</span><span class="o">[</span><span class="n">lhs</span><span class="o">].</span><span class="n">send</span><span class="p">(</span><span class="vi">@comparator</span><span class="p">,</span> <span class="vi">@data</span><span class="o">[</span><span class="n">rhs</span><span class="o">]</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">swap!</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="vi">@data</span><span class="o">[</span><span class="n">a</span><span class="o">]</span><span class="p">,</span> <span class="vi">@data</span><span class="o">[</span><span class="n">b</span><span class="o">]</span> <span class="o">=</span> <span class="vi">@data</span><span class="o">[</span><span class="n">b</span><span class="o">]</span><span class="p">,</span> <span class="vi">@data</span><span class="o">[</span><span class="n">a</span><span class="o">]</span>
  <span class="k">end</span>

<span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-Usage'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-Usage">&#182;</a>
        </div>
        <h2>Usage</h2>

<p>These subclasses show that the above algorithm supports arbitrary comparison
operations, in this case both a min-heap and a max-heap.</p>
      </td>
      <td class=code>
        <div class='highlight'><pre><span class="k">class</span> <span class="nc">MaxHeap</span> <span class="o">&lt;</span> <span class="no">BinaryHeap</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="k">super</span><span class="p">(</span><span class="ss">:&gt;</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">MinHeap</span> <span class="o">&lt;</span> <span class="no">BinaryHeap</span>
  <span class="k">def</span> <span class="nf">initialize</span>
    <span class="k">super</span><span class="p">(:</span><span class="o">&lt;</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span></pre></div>
      </td>
    </tr>
    <tr id='section-11'>
      <td class=docs>
        <div class="pilwrap">
          <a class="pilcrow" href="#section-11">&#182;</a>
        </div>
        <p>Quick-check style specs that ensure the heap property invariant is
upheld regardless of the sequence of input. Enough elements to fill at least
four levels of the tree are used to ensure that the <code>bubble_up</code> and
<code>bubble_down</code> methods are tested sufficiently.</p>

      </td>
      <td class=code>
        <div class='highlight'><pre><span class="nb">require</span> <span class="s1">&#39;rspec&#39;</span>

<span class="n">test_elements</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">.</span><span class="n">.</span><span class="mi">2</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">to_a</span>

<span class="n">shared_examples_for</span> <span class="s1">&#39;a heap&#39;</span> <span class="k">do</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:heap</span><span class="p">)</span> <span class="p">{</span> <span class="n">subject</span> <span class="p">}</span>

  <span class="mi">15</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">map</span> <span class="p">{</span><span class="n">test_elements</span><span class="o">.</span><span class="n">sort_by</span><span class="p">{</span><span class="nb">rand</span><span class="p">}}</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">example</span><span class="o">|</span>
    <span class="n">it</span> <span class="s2">&quot;always pops greatest value for </span><span class="si">#{</span><span class="n">example</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">do</span>
      <span class="n">example</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span><span class="o">|</span><span class="n">x</span><span class="o">|</span> <span class="n">heap</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="p">}</span>
      <span class="n">elements</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">x</span><span class="o">|</span>
        <span class="n">heap</span><span class="o">.</span><span class="n">top</span><span class="o">.</span><span class="n">should</span> <span class="o">==</span> <span class="n">x</span>
        <span class="n">heap</span><span class="o">.</span><span class="n">pop</span><span class="o">.</span><span class="n">should</span> <span class="o">==</span> <span class="n">x</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="n">it</span> <span class="s1">&#39;allows duplicate values&#39;</span> <span class="k">do</span>
    <span class="n">heap</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
    <span class="n">heap</span><span class="o">.</span><span class="n">pop</span><span class="o">.</span><span class="n">should</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="n">heap</span><span class="o">.</span><span class="n">pop</span><span class="o">.</span><span class="n">should</span> <span class="o">==</span> <span class="mi">1</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">describe</span> <span class="no">MaxHeap</span> <span class="k">do</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:elements</span><span class="p">)</span> <span class="p">{</span> <span class="n">test_elements</span><span class="o">.</span><span class="n">reverse</span> <span class="p">}</span>

  <span class="n">it_should_behave_like</span> <span class="s1">&#39;a heap&#39;</span>
<span class="k">end</span>

<span class="n">describe</span> <span class="no">MinHeap</span> <span class="k">do</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:elements</span><span class="p">)</span> <span class="p">{</span> <span class="n">test_elements</span> <span class="p">}</span>

  <span class="n">it_should_behave_like</span> <span class="s1">&#39;a heap&#39;</span>
<span class="k">end</span></pre></div>
      </td>
    </tr>
  </table>
</div>
</body>
